generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id               String   @id @default(cuid())
  username         String   @unique
  email            String   @unique
  phone            String?  @unique
  password         String
  sponsorId        String?  // Who REFERRED this user (for direct bonus)
  sponsor          User?    @relation("Sponsorship", fields: [sponsorId], references: [id])
  referrals        User[]   @relation("Sponsorship")
  parentId         String?  // PLACEMENT parent in binary tree (for matching structure)
  parent           User?    @relation("TreePlacement", fields: [parentId], references: [id])
  children         User[]   @relation("TreePlacement")
  role             Role     @default(USER)
  kycStatus        String   @default("NOT_STARTED") // NOT_STARTED, IN_PROGRESS, VERIFIED, FAILED
  kycRefId         String?
  pan              String?
  aadhaar          String?
  isEmailVerified  Boolean  @default(false)
  emailVerifyToken String?
  resetToken       String?
  resetTokenExpiry DateTime?
  isBlocked        Boolean  @default(false)
  fraudFlag        Boolean  @default(false)
  hasPurchased     Boolean  @default(false)  // Must purchase before referring
  rank             String   @default("Rookie")
  totalPairs       Int      @default(0)
  createdAt        DateTime @default(now())
  // BV fields (legacy, kept for backward compatibility)
  leftBV           Int      @default(0)
  rightBV          Int      @default(0)
  leftCarryBV      Int      @default(0)
  rightCarryBV     Int      @default(0)
  // Member count fields for 2:1/1:2 matching
  leftMemberCount  Int      @default(0)  // members in left leg
  rightMemberCount Int      @default(0)  // members in right leg
  leftCarryCount   Int      @default(0)  // carry-forward left members
  rightCarryCount  Int      @default(0)  // carry-forward right members
  position         Position?  // LEFT or RIGHT relative to parentId
  wallet           Wallet?
  transactions     Transaction[]
  withdrawals      Withdrawal[]
  pairPayouts      PairPayoutRecord[]
  dailyPairCounters DailyPairCounter[]
  rankChanges      RankChange[]
}

model RankChange {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id])
  fromRank      String    // Previous rank (or "None" for first)
  toRank        String    // New rank achieved
  pairsAtChange Int       // Total pairs when promotion happened
  rewarded      Boolean   @default(false)
  rewardedAt    DateTime?
  rewardedBy    String?   // Admin who marked rewarded
  createdAt     DateTime  @default(now())

  @@index([userId])
  @@index([toRank])
  @@index([rewarded])
}

model Product {
  id          String   @id @default(cuid())
  name        String
  price       Int
  bv          Int
  description String?
  stock       Int      @default(0)
  imageUrl    String?
  createdAt   DateTime @default(now())
}

model Wallet {
  id        String  @id @default(cuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String  @unique
  balance   Int     @default(0)
  createdAt DateTime @default(now())
}

model Transaction {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  type      TxType
  amount    Int
  detail    String?
  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  action    String
  actorId   String?
  meta      String?
  createdAt DateTime @default(now())
}

model PairPayoutRecord {
  id              String   @id @default(cuid())
  user            User     @relation(fields: [userId], references: [id])
  userId          String
  date            DateTime
  pairs           Int      @default(0)
  amount          Int      @default(0)
  matchType       String?  // "2:1" or "1:2" or "mixed"
  membersConsumed Int      @default(0)  // Total members consumed (pairs * 3)
  leftConsumed    Int      @default(0)  // Members consumed from left side
  rightConsumed   Int      @default(0)  // Members consumed from right side
  createdAt       DateTime @default(now())

  @@index([userId, date])
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  revoked   Boolean  @default(false)
  createdAt DateTime @default(now())
}

model DailyPairCounter {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  date      DateTime
  pairs     Int      @default(0)
  createdAt DateTime @default(now())

  @@index([userId, date])
  @@unique([userId, date])
}

enum Role {
  ADMIN
  USER
}

enum TxType {
  PURCHASE
  DIRECT_BONUS
  MATCHING_BONUS
  WITHDRAW
  REFUND
  ADMIN_CREDIT
  ADMIN_DEBIT
}

enum Position {
  LEFT
  RIGHT
  ROOT
}

model Withdrawal {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  amount    Int
  status    WithdrawalStatus @default(PENDING)
  bankDetails String?
  createdAt DateTime @default(now())
  approvedAt DateTime?
  approvedBy String?

  @@index([userId, status])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}
