const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
const crypto = require('crypto');

/**
 * Calculate 2:1 / 1:2 matching for asymmetric binary plan.
 * 
 * Rules:
 * - 2:1 match = 2 left members + 1 right member (3 members consumed)
 * - 1:2 match = 1 left member + 2 right members (3 members consumed)
 * - Each match = 3 members consumed total
 * - Carry forward unmatched members
 * 
 * @param {number} leftCount - Total left leg member count (including carry)
 * @param {number} rightCount - Total right leg member count (including carry)
 * @returns {object} Matching calculation result
 */
function calculate2to1Matching(leftCount, rightCount) {
    let left = leftCount;
    let right = rightCount;
    let twoOneMatches = 0;
    let oneTwoMatches = 0;

    // Strategy: Maximize total matches
    // Process matches greedily based on which leg is stronger
    while ((left >= 2 && right >= 1) || (left >= 1 && right >= 2)) {
        // Check which match type is possible
        const canDoTwoOne = left >= 2 && right >= 1;
        const canDoOneTwo = left >= 1 && right >= 2;

        if (canDoTwoOne && canDoOneTwo) {
            // Both possible - choose based on which leg has more surplus
            if (left > right * 2) {
                // Left-heavy: do 2:1 to consume more left
                twoOneMatches++;
                left -= 2;
                right -= 1;
            } else if (right > left * 2) {
                // Right-heavy: do 1:2 to consume more right
                oneTwoMatches++;
                left -= 1;
                right -= 2;
            } else {
                // Balanced: alternate or prefer 2:1
                twoOneMatches++;
                left -= 2;
                right -= 1;
            }
        } else if (canDoTwoOne) {
            twoOneMatches++;
            left -= 2;
            right -= 1;
        } else if (canDoOneTwo) {
            oneTwoMatches++;
            left -= 1;
            right -= 2;
        } else {
            break;
        }
    }

    const totalMatches = twoOneMatches + oneTwoMatches;
    const membersConsumed = totalMatches * 3;

    // Determine match type string
    let matchType = 'none';
    if (twoOneMatches > 0 && oneTwoMatches > 0) {
        matchType = 'mixed';
    } else if (twoOneMatches > 0) {
        matchType = '2:1';
    } else if (oneTwoMatches > 0) {
        matchType = '1:2';
    }

    return {
        twoOneMatches,
        oneTwoMatches,
        totalMatches,
        membersConsumed,
        carryLeft: left,
        carryRight: right,
        matchType
    };
}

/**
 * Credit direct referral bonus to sponsor wallet.
 * Wrapped in a transaction to ensure atomicity.
 */
async function creditDirectBonus(prismaClient, sponsorId, bv) {
    const bonusAmount = parseInt(process.env.DIRECT_BONUS_AMOUNT || '500', 10);
    const db = prismaClient || prisma;

    if (prismaClient) {
        await prismaClient.transaction.create({
            data: { userId: sponsorId, type: 'DIRECT_BONUS', amount: bonusAmount, detail: `Direct bonus for referral (BV ${bv})` }
        });
        await prismaClient.wallet.upsert({
            where: { userId: sponsorId },
            update: { balance: { increment: bonusAmount } },
            create: { userId: sponsorId, balance: bonusAmount }
        });
        await prismaClient.auditLog.create({
            data: { action: 'DIRECT_BONUS', actorId: sponsorId, meta: `amount:${bonusAmount},bv:${bv}` }
        });
        return;
    }

    await db.$transaction(async (tx) => {
        await tx.transaction.create({
            data: { userId: sponsorId, type: 'DIRECT_BONUS', amount: bonusAmount, detail: `Direct bonus for referral (BV ${bv})` }
        });
        await tx.wallet.upsert({
            where: { userId: sponsorId },
            update: { balance: { increment: bonusAmount } },
            create: { userId: sponsorId, balance: bonusAmount }
        });
        await tx.auditLog.create({
            data: { action: 'DIRECT_BONUS', actorId: sponsorId, meta: `amount:${bonusAmount},bv:${bv}` }
        });
    });
}

/**
 * Process matching bonus using 2:1 / 1:2 algorithm.
 * Uses member counts instead of BV.
 * 
 * @param {object} prismaClient - Optional Prisma transaction client
 * @param {string} userId - User ID to process matching for
 * @param {number} dailyPairCap - Optional daily cap override
 */
async function processMatchingBonus(prismaClient, userId, dailyPairCap = null) {
    const db = prismaClient || prisma;
    const bonusPerMatch = parseInt(process.env.MATCHING_BONUS_PER_MATCH || '700', 10);
    const cap = dailyPairCap === null ? parseInt(process.env.DAILY_PAIR_CAP || '10', 10) : dailyPairCap;

    // Advisory lock key from userId
    const lockKey = parseInt(crypto.createHash('sha256').update(userId).digest('hex').slice(0, 8), 16);

    const runMatching = async (tx) => {
        // Acquire advisory lock
        try {
            await tx.$executeRaw`SELECT pg_advisory_xact_lock(${BigInt(lockKey)})`;
        } catch (e) { }

        const user = await tx.user.findUnique({ where: { id: userId } });
        if (!user) return null;

        // Use member counts (current + carry forward)
        const leftTotal = (user.leftMemberCount || 0) + (user.leftCarryCount || 0);
        const rightTotal = (user.rightMemberCount || 0) + (user.rightCarryCount || 0);

        if (leftTotal <= 0 || rightTotal <= 0) return null;

        // Calculate possible matches
        const matchResult = calculate2to1Matching(leftTotal, rightTotal);
        if (matchResult.totalMatches <= 0) return null;

        // Apply daily cap
        const today = new Date();
        today.setUTCHours(0, 0, 0, 0);

        let counter = await tx.dailyPairCounter.findFirst({ where: { userId, date: today } });
        const alreadyToday = counter ? counter.pairs : 0;
        const availableToday = Math.max(0, cap - alreadyToday);

        if (availableToday <= 0) return null;

        // Limit matches to daily cap
        const matchesToPay = Math.min(matchResult.totalMatches, availableToday);
        if (matchesToPay <= 0) return null;

        // Recalculate if we had to limit matches
        let finalResult = matchResult;
        if (matchesToPay < matchResult.totalMatches) {
            // Need to recalculate with limited matches
            // For simplicity, use the greedy matching up to matchesToPay
            finalResult = calculate2to1MatchingLimited(leftTotal, rightTotal, matchesToPay);
        }

        const membersConsumed = matchesToPay * 3;
        const bonus = matchesToPay * bonusPerMatch;

        // Create transaction record
        await tx.transaction.create({
            data: {
                userId,
                type: 'MATCHING_BONUS',
                amount: bonus,
                detail: `Matching bonus for ${matchesToPay} matches (${finalResult.matchType}, ${membersConsumed} members consumed)`
            }
        });

        // Update wallet
        await tx.wallet.upsert({
            where: { userId },
            update: { balance: { increment: bonus } },
            create: { userId, balance: bonus }
        });

        // Update member counts - reset current and set carry
        await tx.user.update({
            where: { id: userId },
            data: {
                leftMemberCount: 0,
                rightMemberCount: 0,
                leftCarryCount: finalResult.carryLeft,
                rightCarryCount: finalResult.carryRight
            }
        });

        // Create payout record
        const payout = await tx.pairPayoutRecord.create({
            data: {
                userId,
                date: today,
                pairs: matchesToPay,
                amount: bonus,
                matchType: finalResult.matchType,
                membersConsumed
            }
        });

        // Update daily counter
        if (counter) {
            await tx.dailyPairCounter.update({
                where: { id: counter.id },
                data: { pairs: counter.pairs + matchesToPay }
            });
        } else {
            try {
                await tx.dailyPairCounter.create({
                    data: { userId, date: today, pairs: matchesToPay }
                });
            } catch (e) {
                if (e?.code === 'P2002' || e?.message?.includes('Unique constraint')) {
                    await tx.dailyPairCounter.updateMany({
                        where: { userId, date: today },
                        data: { pairs: { increment: matchesToPay } }
                    });
                } else {
                    throw e;
                }
            }

            // Audit log removed - payout is already recorded in PairPayoutRecord

            // Broadcast (best-effort)
            try {
                const { broadcastPayout } = require('../routes/sse');
                broadcastPayout(payout).catch?.(() => { });
            } catch (e) { }

            try {
                const { info } = require('../logger');
                info('pair-payout-2-1', { userId, payoutId: payout.id, amount: bonus, matches: matchesToPay });
            } catch (e) { }

            return payout;
        };

        if (prismaClient) {
            return await runMatching(prismaClient);
        }

        return await db.$transaction(runMatching);
    }

    /**
     * Calculate matching with a limit on total matches.
     */
    function calculate2to1MatchingLimited(leftCount, rightCount, maxMatches) {
        let left = leftCount;
        let right = rightCount;
        let twoOneMatches = 0;
        let oneTwoMatches = 0;
        let totalMatches = 0;

        while (totalMatches < maxMatches && ((left >= 2 && right >= 1) || (left >= 1 && right >= 2))) {
            const canDoTwoOne = left >= 2 && right >= 1;
            const canDoOneTwo = left >= 1 && right >= 2;

            if (canDoTwoOne && canDoOneTwo) {
                if (left > right * 2) {
                    twoOneMatches++;
                    left -= 2;
                    right -= 1;
                } else if (right > left * 2) {
                    oneTwoMatches++;
                    left -= 1;
                    right -= 2;
                } else {
                    twoOneMatches++;
                    left -= 2;
                    right -= 1;
                }
            } else if (canDoTwoOne) {
                twoOneMatches++;
                left -= 2;
                right -= 1;
            } else if (canDoOneTwo) {
                oneTwoMatches++;
                left -= 1;
                right -= 2;
            } else {
                break;
            }
            totalMatches++;
        }

        let matchType = 'none';
        if (twoOneMatches > 0 && oneTwoMatches > 0) {
            matchType = 'mixed';
        } else if (twoOneMatches > 0) {
            matchType = '2:1';
        } else if (oneTwoMatches > 0) {
            matchType = '1:2';
        }

        return {
            twoOneMatches,
            oneTwoMatches,
            totalMatches,
            membersConsumed: totalMatches * 3,
            carryLeft: left,
            carryRight: right,
            matchType
        };
    }

    module.exports = { creditDirectBonus, processMatchingBonus, calculate2to1Matching };



